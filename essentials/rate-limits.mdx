---
title: 'Rate Limits'
description: 'Understand API rate limits, quota management, and best practices for handling limits'
---

# Rate Limits

The Influship API implements rate limiting to ensure fair usage and system stability. Understanding these limits helps you build robust applications.

## Rate Limit Overview

Rate limits are applied per API key and vary by your billing plan. All responses include rate limit information in headers.

<Info>
**Rate Limit Headers**: Every response includes `RateLimit-Limit`, `RateLimit-Remaining`, and `RateLimit-Reset` headers for monitoring.
</Info>

## Rate Limit Tiers

### üÜì Free Tier
- **Requests per hour**: 1,000
- **Burst capacity**: 100 requests/minute
- **Perfect for**: Development, testing, small applications

### üíº Pro Tier  
- **Requests per hour**: 10,000
- **Burst capacity**: 500 requests/minute
- **Perfect for**: Production applications, agencies

### üè¢ Enterprise
- **Requests per hour**: Custom (typically 50,000+)
- **Burst capacity**: Custom
- **Perfect for**: High-volume applications, white-label solutions

## Rate Limit Headers

Every API response includes these headers:

```http
RateLimit-Limit: 10000
RateLimit-Remaining: 9997
RateLimit-Reset: 1640995200
```

<ParamField header="RateLimit-Limit" type="integer">
Total number of requests allowed in the current time window
</ParamField>

<ParamField header="RateLimit-Remaining" type="integer">
Number of requests remaining in the current time window
</ParamField>

<ParamField header="RateLimit-Reset" type="integer">
Unix timestamp (seconds) when the rate limit resets
</ParamField>

## Handling Rate Limits

### 429 Too Many Requests

When you exceed rate limits, you'll receive a 429 response:

<ResponseExample>
```json 429 Too Many Requests
{
  "error": {
    "code": "rate_limit_exceeded",
    "message": "Rate limit exceeded. Try again later.",
    "details": {
      "limit": 10000,
      "remaining": 0,
      "reset": 1640995200,
      "retry_after": 3600
    },
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```
</ResponseExample>

### Retry-After Header

429 responses include a `Retry-After` header indicating when to retry:

```http
Retry-After: 3600
```

## Best Practices

### Implement Exponential Backoff

```javascript
async function makeRequestWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        const delay = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;
        
        console.log(`Rate limited. Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      return response;
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;
      
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Monitor Rate Limit Headers

```javascript
function checkRateLimit(response) {
  const limit = parseInt(response.headers.get('RateLimit-Limit'));
  const remaining = parseInt(response.headers.get('RateLimit-Remaining'));
  const reset = parseInt(response.headers.get('RateLimit-Reset'));
  
  const usagePercentage = ((limit - remaining) / limit) * 100;
  
  if (usagePercentage > 80) {
    console.warn(`Rate limit usage: ${usagePercentage.toFixed(1)}%`);
  }
  
  if (usagePercentage > 95) {
    console.error('Rate limit nearly exceeded! Consider reducing request frequency.');
  }
  
  return {
    limit,
    remaining,
    reset: new Date(reset * 1000),
    usagePercentage
  };
}
```

### Batch Requests When Possible

```javascript
// ‚ùå Inefficient - multiple requests
const creators = await Promise.all([
  getCreator('creator1'),
  getCreator('creator2'),
  getCreator('creator3')
]);

// ‚úÖ Efficient - single batch request
const creators = await getCreators(['creator1', 'creator2', 'creator3']);
```

## Rate Limit Strategies

### 1. Request Queuing

```javascript
class RateLimitQueue {
  constructor(requestsPerSecond = 10) {
    this.queue = [];
    this.interval = 1000 / requestsPerSecond;
    this.processing = false;
  }
  
  async add(requestFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ requestFn, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    
    while (this.queue.length > 0) {
      const { requestFn, resolve, reject } = this.queue.shift();
      
      try {
        const result = await requestFn();
        resolve(result);
      } catch (error) {
        reject(error);
      }
      
      await new Promise(resolve => setTimeout(resolve, this.interval));
    }
    
    this.processing = false;
  }
}
```

### 2. Adaptive Rate Limiting

```javascript
class AdaptiveRateLimiter {
  constructor() {
    this.requestTimes = [];
    this.baseInterval = 100; // Start with 100ms between requests
  }
  
  async makeRequest(requestFn) {
    // Clean old request times (older than 1 minute)
    const oneMinuteAgo = Date.now() - 60000;
    this.requestTimes = this.requestTimes.filter(time => time > oneMinuteAgo);
    
    // Calculate current rate
    const currentRate = this.requestTimes.length / 60; // requests per second
    
    // Adjust interval based on rate
    if (currentRate > 8) { // Close to 10 req/sec limit
      this.baseInterval *= 1.2;
    } else if (currentRate < 5) {
      this.baseInterval *= 0.9;
    }
    
    // Wait if necessary
    if (this.requestTimes.length > 0) {
      const timeSinceLastRequest = Date.now() - this.requestTimes[this.requestTimes.length - 1];
      if (timeSinceLastRequest < this.baseInterval) {
        await new Promise(resolve => setTimeout(resolve, this.baseInterval - timeSinceLastRequest));
      }
    }
    
    // Record this request
    this.requestTimes.push(Date.now());
    
    return requestFn();
  }
}
```

## Monitoring and Alerts

### Set Up Monitoring

```javascript
class RateLimitMonitor {
  constructor(alertThreshold = 0.8) {
    this.alertThreshold = alertThreshold;
    this.usageHistory = [];
  }
  
  checkUsage(response) {
    const limit = parseInt(response.headers.get('RateLimit-Limit'));
    const remaining = parseInt(response.headers.get('RateLimit-Remaining'));
    const usage = (limit - remaining) / limit;
    
    this.usageHistory.push({
      timestamp: Date.now(),
      usage,
      limit,
      remaining
    });
    
    if (usage > this.alertThreshold) {
      this.sendAlert(usage, limit, remaining);
    }
  }
  
  sendAlert(usage, limit, remaining) {
    console.warn(`Rate limit alert: ${(usage * 100).toFixed(1)}% usage (${remaining}/${limit} remaining)`);
    
    // Send to monitoring service
    // this.monitoringService.alert('rate_limit_high', { usage, limit, remaining });
  }
}
```

## Common Scenarios

### High-Volume Data Processing

<Steps>
<Step title="Batch Operations">
  Use batch endpoints to reduce the number of API calls.
</Step>

<Step title="Implement Queuing">
  Queue requests to stay within rate limits.
</Step>

<Step title="Monitor Headers">
  Check rate limit headers and adjust request frequency.
</Step>

<Step title="Consider Upgrading">
  If consistently hitting limits, consider upgrading your plan.
</Step>
</Steps>

### Real-Time Applications

<Steps>
<Step title="Use Webhooks">
  Subscribe to webhooks instead of polling for updates.
</Step>

<Step title="Cache Aggressively">
  Cache data to reduce API calls.
</Step>

<Step title="Optimize Queries">
  Use filters and pagination to reduce data transfer.
</Step>
</Steps>

## Troubleshooting

### Rate Limit Issues

<AccordionGroup>
<Accordion title="Getting 429 errors frequently">
  - Check your request frequency
  - Implement exponential backoff
  - Consider upgrading your plan
  - Use batch requests when possible
</Accordion>

<Accordion title="Rate limits seem too low">
  - Verify you're using the correct API key
  - Check your billing plan
  - Contact support for custom limits
  - Review your request patterns
</Accordion>

<Accordion title="Headers not showing">
  - Ensure you're reading response headers correctly
  - Check that you're making requests to the correct endpoint
  - Verify your API key is valid
</Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
<Card title="Pricing Guide" icon="dollar-sign" href="/essentials/pricing">
  Understand credit costs and billing
</Card>

<Card title="Best Practices" icon="star" href="/guides/autocomplete-best-practices">
  Learn optimization techniques
</Card>
</CardGroup>
