---
title: 'Creator Autocomplete Best Practices'
description: 'Learn how to implement efficient creator autocomplete with proper debouncing and rate limiting'
---

# Creator Autocomplete Best Practices

The Creator Autocomplete API is designed for real-time search suggestions as users type. To ensure optimal performance and cost efficiency, follow these best practices.

## Debouncing

**Always implement client-side debouncing** to avoid excessive API calls. The API is designed for autocomplete use cases, not real-time search.

### Recommended Debounce Settings

- **Minimum delay**: 300ms between requests
- **Minimum query length**: 2 characters
- **Maximum requests per second**: 10 (per API key)

### JavaScript Example

```javascript
function createAutocomplete(inputElement, onResults) {
  let debounceTimer;

  inputElement.addEventListener('input', (e) => {
    const query = e.target.value.trim();

    // Clear previous timer
    clearTimeout(debounceTimer);

    // Don't search for queries shorter than 2 characters
    if (query.length < 2) {
      onResults([]);
      return;
    }

    // Debounce the API call
    debounceTimer = setTimeout(async () => {
      try {
        const response = await fetch(
          `https://api.influship.com/v1/creators/autocomplete?q=${encodeURIComponent(
            query
          )}`,
          {
            headers: {
              'X-API-Key': 'your-api-key-here',
            },
          }
        );

        const data = await response.json();
        onResults(data.results || []);
      } catch (error) {
        console.error('Autocomplete error:', error);
        onResults([]);
      }
    }, 300); // 300ms delay
  });
}
```

### React Example

```jsx
import { useState, useEffect, useCallback } from 'react';

function CreatorAutocomplete() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);

  const searchCreators = useCallback(async (searchQuery) => {
    if (searchQuery.length < 2) {
      setResults([]);
      return;
    }

    setLoading(true);
    try {
      const response = await fetch(
        `https://api.influship.com/v1/creators/autocomplete?q=${encodeURIComponent(
          searchQuery
        )}`,
        {
          headers: {
            'X-API-Key': process.env.REACT_APP_INFLUSHIP_API_KEY,
          },
        }
      );

      const data = await response.json();
      setResults(data.results || []);
    } catch (error) {
      console.error('Autocomplete error:', error);
      setResults([]);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    const debounceTimer = setTimeout(() => {
      searchCreators(query);
    }, 300);

    return () => clearTimeout(debounceTimer);
  }, [query, searchCreators]);

  return (
    <div>
      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search creators...'
      />

      {loading && <div>Searching...</div>}

      <ul>
        {results.map((creator) => (
          <li key={creator.id}>
            <img src={creator.avatar_url} alt={creator.name} />
            <div>
              <strong>{creator.name}</strong>
              {creator.platforms.map((platform) => (
                <div key={platform.platform}>
                  {platform.platform}: @{platform.username}
                  {platform.match_type === 'username' && ' (matched username)'}
                  {platform.match_type === 'display_name' &&
                    ' (matched display name)'}
                </div>
              ))}
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Rate Limiting

The API includes built-in rate limiting:

- **Free tier**: 1,000 requests/hour
- **Pro tier**: 10,000 requests/hour

Monitor the response headers to track your usage:

```javascript
const response = await fetch(url, options);
const remaining = response.headers.get('RateLimit-Remaining');
const resetTime = response.headers.get('RateLimit-Reset');

console.log(`Requests remaining: ${remaining}`);
console.log(`Rate limit resets at: ${new Date(resetTime * 1000)}`);
```

## Error Handling

Always implement proper error handling for autocomplete:

```javascript
async function searchCreators(query) {
  try {
    const response = await fetch(url, options);

    if (!response.ok) {
      if (response.status === 429) {
        // Rate limited - implement exponential backoff
        throw new Error('Rate limited. Please slow down your requests.');
      }
      throw new Error(`API error: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Autocomplete error:', error);
    return { results: [] };
  }
}
```

## Caching

Consider implementing client-side caching for frequently searched terms:

```javascript
class AutocompleteCache {
  constructor(maxSize = 100, ttl = 300000) {
    // 5 minutes TTL
    this.cache = new Map();
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  set(key, data) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });
  }
}

const cache = new AutocompleteCache();

async function searchWithCache(query) {
  const cached = cache.get(query);
  if (cached) return cached;

  const results = await searchCreators(query);
  cache.set(query, results);
  return results;
}
```

## Platform Filtering

Use platform filtering to narrow results when you know the target platform:

```javascript
// Search only Instagram creators
const response = await fetch(
  `https://api.influship.com/v1/creators/autocomplete?q=${query}&platform=Instagram`
);

// Search only TikTok creators
const response = await fetch(
  `https://api.influship.com/v1/creators/autocomplete?q=${query}&platform=TikTok`
);
```

## Match Highlighting

The API returns match information to help you highlight the relevant part of the result:

```javascript
function highlightMatch(text, matchType, query) {
  if (matchType === 'name' || matchType === 'display_name') {
    // Highlight the matched part in the name/display name
    const regex = new RegExp(`(${query})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }
  return text;
}

// Usage in your UI
creator.platforms.forEach((platform) => {
  if (platform.match_type === 'username') {
    // Show that the username matched
    console.log(`Username @${platform.username} matched`);
  } else if (platform.match_type === 'display_name') {
    // Show that the display name matched
    console.log(`Display name "${platform.display_name}" matched`);
  }
});
```

## Performance Tips

1. **Minimize API calls**: Use debouncing and caching
2. **Limit results**: Use the `limit` parameter (default: 5, max: 10)
3. **Handle empty states**: Show appropriate messages when no results
4. **Cancel requests**: Cancel in-flight requests when new ones are made
5. **Monitor usage**: Track your API usage to stay within limits

## Cost Optimization

The autocomplete endpoint is very cost-effective:

- **Cost**: 0.001 credits per request
- **Free tier**: 1,000 requests/hour included
- **Pro tier**: 10,000 requests/hour included

This means you can make 1,000,000 autocomplete requests for just 1,000 credits on the free tier!
